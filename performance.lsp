;; STIC Benchmark in uLisp
;; Works with http://www.ulisp.com/ on boards like Arduino, ESP32, etc.

(defvar simple-hanoi nil)

;; Define iteration counts
(defvar iter-1k       1000)
(defvar iter-3k       3000)
(defvar iter-10k     10000)
(defvar iter-100k   100000)
(defvar iter-300k   300000)
(defvar iter-1000k 1000000)

(defun make-list (n fill)
  (if (zerop n)
      nil
      (cons fill (make-list (- n 1) fill))))

(defun move (n from to temp)
  (when (> n 1)
    (move (- n 1) from temp to)
    (move (- n 1) temp to from)))

(defun hanoi ()
 ( / (for-millis () (move 16 1 2 3)) 1000.0))


(defun alloc-speed-test ()
  ( / (for-millis ()
    (dotimes (i iter-100k)
      (let ((a (list 0 0 0 0 0 0 0 0 0 0))
            (b (list 0 0 0 0 0 0 0 0 0 0))
            (c (list 0 0 0 0 0 0 0 0 0 0))
            (d (list 0 0 0 0 0 0 0 0 0 0))
            (e (list 0 0 0 0 0 0 0 0 0 0))
            (f (list 0 0 0 0 0 0 0 0 0 0))
            (g (list 0 0 0 0 0 0 0 0 0 0))
            (h (list 0 0 0 0 0 0 0 0 0 0))
            (i (list 0 0 0 0 0 0 0 0 0 0))
            (j (list 0 0 0 0 0 0 0 0 0 0))
          )
        )
      )
      ) 1000.0))

(defun array-write-speed-test ()
  (let ((junk (list 0))
        (array (make-list 10 0)))
    ( / (for-millis ()
      (dotimes (i iter-1000k)
        (dotimes (j 10)
          (setf (nth j array) junk)))) 1000.0)))

(defun dictionary-write-speed-test ()
  ;; uLisp doesn't have native dictionaries, simulate with assoc list
  (let ((junk (list 0))
        (keys '(a b c d e f g h i j)))
  ( / (for-millis ()
    (dotimes (i iter-10k)
      (let ((dict nil))
        (dolist (key keys)
          (push (cons key junk) dict))))) 1000.0)))

(defun float-math-speed-test ()
  (let ((a 87.0) (b 53.0) (c -87.0) (d 42461.0) (e 5.0))
    (/ (for-millis ()
      (dotimes (i iter-300k)
        (dotimes (j 10)
          (setf e (+ (* (+ (* e a) b) c) d))))) 1000.0)))

(defun integer-math-speed-test ()
  (let ((a 87) (b 53) (c -87) (d 42461) (e 5))
    ( / (for-millis ()
      (dotimes (i iter-300k)
        (dotimes (j 10)
          (setf e (+ (* (+ (* e a) b) c) d))))) 1000.0)))

(defun collection-iterate-test ()
  (let* ((junk (list 0)) 
        (oc (make-list 20 junk)))
    (/ (for-millis () 
      (dotimes (i iter-100k)
        (dotimes (j 10)
          (dolist (item oc) item)))) 1000.0 )))

(defun collection-write-test ()
  (let ((junk (list 0)))
    ( / (for-millis () 
      (dotimes (i iter-100k)
        (let ((oc nil))
          (dotimes (j 10)
            (push junk oc))))) 1000.0)))

(defun string-compare-speed-test ()
  (let ((s1 "thes is a test of a string compare of two long strings")
        (s2 "thes is a test of a string compare of two long strings"))
    ( / (for-millis () 
      (dotimes (i iter-100k)
        (dotimes (j 10)
          (string= s1 s2)))) 1000.0)))

(defun run-all ()
  (let ((results (make-list 9 0)))
    (setf (nth 0 results) (alloc-speed-test))
    (setf (nth 1 results) (array-write-speed-test))
    (setf (nth 2 results) (dictionary-write-speed-test))
    (setf (nth 3 results) (float-math-speed-test))
    (setf (nth 4 results) (integer-math-speed-test))
    (setf (nth 5 results) (collection-iterate-test))
    (setf (nth 6 results) (collection-write-test))
    (setf (nth 7 results) (string-compare-speed-test))
    (setf (nth 8 results) (hanoi))
    results))

(defun print-results (results)
  (format t "STIC benchmark ---------------------------~%")
  (format t "   (smaller numbers are better)~%")
  (format t "alloc               ~a~%" (nth 0 results))
  (format t "array write         ~a~%" (nth 1 results))
  (format t "dictionary write    ~a~%" (nth 2 results))
  (format t "float math          ~a~%" (nth 3 results))
  (format t "integer math        ~a~%" (nth 4 results))
  (format t "collection iterate  ~a~%" (nth 5 results))
  (format t "collection write    ~a~%" (nth 6 results))
  (format t "string compare      ~a~%" (nth 7 results))
  (format t "hanoi               ~a~%" (nth 8 results))
  (format t "-------------------------------------------~%"))

(defun benchmark ()
  (let ((results1 (run-all))
        (results2 (run-all))
        (results3 (run-all))
        (avg-results (make-list 9 0)))
    (dotimes (i 9)
      (setf (nth i avg-results)
            (/ (+ (nth i results1)
                  (nth i results2)
                  (nth i results3))
               3.0)))
    (print-results avg-results)))

(defun benchy ()
  (let* ((results1 (run-all))
        (avg-results (make-list 9 0)))
    (print-results results1)))

;; Run it:
(benchy)          